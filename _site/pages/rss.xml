<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>琼小资的博客</title>
    <link>http://blog.withouz.com</link>
    <description>琼小资的博客</description>
    
      <item>
        <title>读《明朝那些事儿》</title>
        <link>http://blog.withouz.com/2016/07/31/read-mingchao-history.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/07/31/read-mingchao-history.html</guid>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;老早就知道这本书，不过只限于道听途说，最初印象还以为是易中天的作品。&lt;/p&gt;

&lt;p&gt;直到真正接触书，才发现自己的无知。&lt;/p&gt;

&lt;p&gt;《明朝那些事儿》，作者石悦，网名当年明月。最早在天涯论坛以贴子形式发布，后来转到新浪微博。再后来出版，并不惜千万稿费使电子版免费。&lt;/p&gt;

&lt;p&gt;我是这个电子版免费的受益者。&lt;/p&gt;

&lt;p&gt;最近出了一个新闻，说已超市收银员被顾客（老人）扇耳光后又被领导调节罚工资，收银员随即到货架上找了把刀了结了自己的生命。网上很多这新闻的评论，而说的最多的是如何尊老。我觉得就这事最中肯的一个观点是，我们只尊重行为，不关乎年龄。&lt;/p&gt;

&lt;p&gt;石悦显然是值得尊敬的，他让更多的人看明白了明朝这段历史。&lt;/p&gt;

&lt;p&gt;对于不怎么感兴趣的人来说，读史是件很枯燥的事，因此很少有人能真正能去有耐心的阅读历史。尤其是现代人，古文很难懂，读古文吃力，而中国历史基本上都是古文。&lt;/p&gt;

&lt;p&gt;《明朝那些事儿》解决了这些难题，作者尽力保持了历史原貌，无法考据的会特殊说明。不仅历史白文化，还给每个历史人物注入了灵魂。整个历史就像一个浮现在眼前的舞台，浪淘不尽的英雄，轮番上演，你方唱罢我登场。&lt;/p&gt;

&lt;p&gt;精彩绝伦。&lt;/p&gt;

&lt;p&gt;时势造英雄，感觉整个朝代开创到覆灭，英雄人物都是一波一波的。&lt;/p&gt;

&lt;p&gt;从朱元璋开始，整个天下都是军事天才，徐达，刘伯温，常遇春。基本上都是身经百战且战无不胜的军事家。&lt;/p&gt;

&lt;p&gt;包括之前与朱元璋一起征战，后来把侄子建文帝干掉的永乐大帝朱棣。都是不折不扣的战斗机。&lt;/p&gt;

&lt;p&gt;但是好景不长，由于朱元璋大哥掌控欲太强，废掉了丞相一职，成立了锦衣卫，内阁。因此后来就出现了宦官（东厂，西厂）专权，内阁专政，把皇帝当棋子。&lt;/p&gt;

&lt;p&gt;富不过三代，从明朝历代皇帝那里也能体会一二。人与人的差别实在太大，龙不一定生龙，凤也不一定能生凤。老子牛逼的，儿子不一定牛逼。好皇帝不一定是好人，而好人也不一定能当好皇帝。而好人也不一定能比坏人对这个世界更有用。&lt;/p&gt;

&lt;p&gt;但人总要有自己的原则，而人类进步的原则，不过是明代大哲学家王阳明的心学核心：&lt;/p&gt;

&lt;p&gt;“无善无恶心之体，有善有恶意之动，知善知恶是良知，为善去恶是格物”&lt;/p&gt;

&lt;p&gt;辨善恶，去恶扬善的格物之心。&lt;/p&gt;

&lt;p&gt;虽然古往今来，好人不一定有好结果，坏人不一定有坏结果。整个朝代都在不断的争斗，明里来暗里去，黑枪暗箭不断，但总的规律到底是邪不胜正。&lt;/p&gt;

&lt;p&gt;王大哲学家虽然生前异常艰苦卓绝，但他的心学影响的后面一大波人直接把整个明朝推向了高潮。&lt;/p&gt;

&lt;p&gt;其中最牛的要算是徐阶和张居正了。这两人的这段历史正事没得说，无论比哪部春秋大戏都精彩。&lt;/p&gt;

&lt;p&gt;徐阶斗倒了当时马屁拍的溜，遇事就缩头的首辅严嵩，明朝的内阁首辅就相当于宰相。并且培养了张居正。&lt;/p&gt;

&lt;p&gt;斗倒严嵩后，徐阶成了首辅，但是徐阶又被后来的高拱斗倒。再后来张居正又把高拱扳倒。&lt;/p&gt;

&lt;p&gt;张居正上台后，当时万历皇帝才十岁，因此整个天下都是他的，想干什么事都是自己写文案，自己审批。&lt;/p&gt;

&lt;p&gt;如果徐阶、张居正不办事，那跟严嵩、高拱没什么区别。&lt;/p&gt;

&lt;p&gt;就政绩而言，张居正应该是整个明代最高的。&lt;/p&gt;

&lt;p&gt;他上台后，开始搞改革。在整个中国封建历史长河中，我们在教科书里只看到了一个失败的王安石变法。而真正成功的却没被写进去。我们的历史教科书如何可见一斑。&lt;/p&gt;

&lt;p&gt;张居正的改革主要搞了两点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;考成法。要求所有官员都要打卡上班，每年干什么事先列出来，年底清算。&lt;/li&gt;
  &lt;li&gt;一条鞭法。统一赋税形式，全部以货币的形式纳税。之前的是渔民纳鱼，谷农交谷。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;先进，那时候能有这样的思想和变革，高山仰止，叹服英雄。&lt;/p&gt;

&lt;p&gt;这段时间一直沉浸在这段历史中，偶尔思想出差，总是会感叹，能写出这本书的人同样值得敬佩，同样堪比英雄。&lt;/p&gt;

&lt;p&gt;关于作者，了解不是很多，觉得有点像明朝的汤显祖，有学问，有能力，但是官不大，一直只能是个六品官，但是伟大的戏剧作家，人尽皆知的《牡丹亭》就是他的代表作。百度百科里的石悦是广东的一个副县长。但浩荡的明朝历史能充分的说明，官衔并不能代表一个人的才能。&lt;/p&gt;

&lt;p&gt;书还没看完，全书七卷，看到第六卷。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>css均分父容器宽度</title>
        <link>http://blog.withouz.com/2016/07/26/css-layout-average.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/07/26/css-layout-average.html</guid>
        <pubDate>Tue, 26 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;在前端布局开发中，我们通常会遇到这样的需求：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/layout_weight.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一个容器视图里有多个水平排列的子视图，这些子视图是均分父容器的宽度。&lt;/p&gt;

&lt;p&gt;我们可以在css中给定RootView的宽度，比如&lt;code&gt;width:100%&lt;/code&gt;，然后给定每个子View的宽度为平均宽度。&lt;/p&gt;

&lt;p&gt;这样是可以满足一部分需求的。&lt;/p&gt;

&lt;p&gt;但如果有更进一步的需求：我们需要根据api的数据来控制这里的子视图的个数。&lt;/p&gt;

&lt;p&gt;当然我们可以通过js动态计算每个子View的宽度，但是那样显得很麻烦。&lt;/p&gt;

&lt;p&gt;是时候挖掘我们强大的css样式了。&lt;/p&gt;

&lt;p&gt;css中display有一个table-cell的值，可以达到我们的需求。&lt;/p&gt;

&lt;p&gt;html代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;table&quot;&amp;gt;
  &amp;lt;div class=&quot;table-cell&quot;&amp;gt;cell1&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;table-cell&quot;&amp;gt;cell2&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;table-cell&quot;&amp;gt;cell3&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;table-cell&quot;&amp;gt;cell4&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;css代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.table{
	width:100%;
	display:table;
}
.table-cell{
	display: table-cell;
	width:1%;
	text-align: center;
	border: 1px solid #eee;
	height:30px;
	line-height: 30px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/layout_cell.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里必须指定tabll-cell的width一个宽度，一般设成1%就行了。&lt;/p&gt;

&lt;p&gt;这样我们就不用在js里去计算了，如果要根据api来按需显示某些cell，可以直接隐藏或显示指定的cell。简单实用。&lt;/p&gt;

&lt;p&gt;很遗憾，这个方法在IE上不兼容，不过这中场景大部分应用在移动端，而如今的移动端，几乎可以不用考虑IE。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>android studio 使用心得</title>
        <link>http://blog.withouz.com/2016/07/02/as_used_feeling.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/07/02/as_used_feeling.html</guid>
        <pubDate>Sat, 02 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;android studio简称安卓开发神器。&lt;/p&gt;

&lt;p&gt;其中有一些功能实在是溜到不行，这里记下几个。&lt;/p&gt;

&lt;h3 id=&quot;style&quot;&gt;自动生成style&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;秉着代码复用的原则，我们的layout文件会尽可能的使用style，这样其他View的样式就可以使用同一个style，这个在静态行式菜单布局会用的特别多。&lt;/p&gt;

&lt;p&gt;如果是在eclipse中，我们要去styles文件里新添一个样式，把属性逐一加到items里面去。这样也很麻烦。&lt;/p&gt;

&lt;p&gt;但在android studio中，我们可以很快搞定。&lt;/p&gt;

&lt;p&gt;只要在layout文件中，选中你写好的样式，右键&amp;gt;Refactor&amp;gt;Extract&amp;gt;Style然后填写样式名称即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/as_auto_build_style.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个功能简直炫到没朋友。&lt;/p&gt;

&lt;h3 id=&quot;github&quot;&gt;从github上加载开源包&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;在eclipse中，我们加载jar包是要下载jar包，然后放到libs下，作为引用。&lt;/p&gt;

&lt;p&gt;但在android studio中，就省事多了，只要一行代码就能搞定。&lt;/p&gt;

&lt;p&gt;我们在build.gradle中添加一条 compile即可。&lt;/p&gt;

&lt;p&gt;比如我们通常用到的xUtils工具，可以这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dependencies {
    ...
    compile &#39;org.xutils:xutils:3.3.34&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后sync即可。&lt;/p&gt;

&lt;h3 id=&quot;beangetset&quot;&gt;对bean文件中的变量添加get/set方法&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;这个功能在eclipse中也有，但确实是个非常爽的功能。&lt;/p&gt;

&lt;p&gt;在android studio中，只要 &lt;code&gt;ctrl+n&lt;/code&gt; 就能添加，也可以单独选择get或者set方法：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/as_get_set.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;快速打开已有安卓工程&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;很多安卓开发者会经常查看一些开源工程的代码，会从github或者其他地方获取到这样的安卓工程，然后用android studio打开来看。&lt;/p&gt;

&lt;p&gt;但是通常会遇到android studio中的gradle和要导入的工程的gradle版本不对应。这样android studio就会半天都打不开这个工程。&lt;/p&gt;

&lt;p&gt;这是android studio一个非常烦的问题。这问题在国外或许没有，但是天朝没办法，只能稍微绕一下。&lt;/p&gt;

&lt;p&gt;gradle版本不对我们可以把版本换成android studio中已有的gradle，这要改两个地方：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 找到要打开的工程里的build.gradle文件，用文本编辑器打开。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;找到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dependencies {
        classpath &#39;com.android.tools.build:gradle:2.1.2&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这行代码，把gradle版本替换成你本地的gradle版本，如果不知道怎么找，可以用android studio创建一个新工程或者已经存在的工程，然后打开build.gradle文件，把这行复制过来。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2 找到要打开的工程的gradle文件夹。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/as_gradle_version.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;把wrapper文件夹下的这两个文件用第一步的方法替换掉。&lt;/p&gt;

&lt;p&gt;完成这两步，再用android studio去打开这个工程，就能快速的打开了。&lt;/p&gt;

&lt;p&gt;原理很简单，就是把要打开的工程的gradle版本换成本地已有的gradle版本。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>写在27岁生日</title>
        <link>http://blog.withouz.com/2016/07/01/birthday-twenty-seven.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/07/01/birthday-twenty-seven.html</guid>
        <pubDate>Fri, 01 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;二十七岁了&lt;/p&gt;

&lt;p&gt;意味着什么呢？&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>Mac下android studio常用快捷键</title>
        <link>http://blog.withouz.com/2016/06/27/as-key-map.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/06/27/as-key-map.html</guid>
        <pubDate>Mon, 27 Jun 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;section&quot;&gt;操作&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;运行工程			&lt;code&gt;ctrl + R&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;拉取Git			&lt;code&gt;command + T&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;提交Git			&lt;code&gt;command + K&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;代码优化			&lt;code&gt;ctrl + alt + O&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;光标&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;移动到行首		&lt;code&gt;ctrl + A&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;移动到行尾		&lt;code&gt;ctrl + E&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;复制整行			&lt;code&gt;command + D&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;删除整行			&lt;code&gt;command + delete&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;前进				&lt;code&gt;ctrl + F&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;后退				&lt;code&gt;ctrl + B&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上一行			&lt;code&gt;ctrl + P&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下一行			&lt;code&gt;ctrl + N&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;后悔&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;后退				&lt;code&gt;command + Z&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;前进				&lt;code&gt;command + shift + Z&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;搜索&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;文件内容搜索		&lt;code&gt;command + F&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;工程内容搜索		&lt;code&gt;command + shift + F&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;类搜索			&lt;code&gt;command + O&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;文件搜索 			&lt;code&gt;command + shift + O&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;最近使用文件搜索 	&lt;code&gt;双击 shift&lt;/code&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>android studio中项目依赖出错</title>
        <link>http://blog.withouz.com/2016/06/20/as-dependence-issue.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/06/20/as-dependence-issue.html</guid>
        <pubDate>Mon, 20 Jun 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;在用android studio开发中开发安卓时遇到一个依赖报错的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Error:(7, 13) Failed to resolve: com.android.support:appcompat-v7:23.2.1
&amp;lt;a href=&quot;install.m2.repo&quot;&amp;gt;Install Repository and sync project&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;&amp;lt;a href=&quot;openFile:/Users/vocient/work/enterprise/project/ent_plus/UnifyApp/build.gradle&quot;&amp;gt;Show in File&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;&amp;lt;a href=&quot;open.dependency.in.project.structure&quot;&amp;gt;Show in Project Structure dialog&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是 &lt;code&gt;appcompat-v7&lt;/code&gt; 这个包没找到&lt;/p&gt;

&lt;p&gt;在android studio中的包依赖与eclipse不一样，eclipse是要把jar包放到libs下作为依赖引用，as更加智能，只要在build.gradle中添加依赖记录即可，as会自动去找，找不到时会提示，可以根据提示下载完成。&lt;/p&gt;

&lt;p&gt;这里我跟着提示去下载这个依赖，结果还是报错，提示说sdk目录下的一个文件夹已经存在，目录是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sdk/extras/android/m2repository/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;报错是已经存在，我先备份一下，然后删除该目录，再重新安装这个依赖，就可以了。&lt;/p&gt;

&lt;p&gt;回头再来看一下这个目录：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/as_support_lib.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这应该是存放安卓sdk额外的一些包的目录，这些包不是sdk所必须，但是又经常会用到的。&lt;/p&gt;

&lt;p&gt;我的as开始会报错的原因是这个文件夹已经存在了，但是又没有 &lt;code&gt;appcompat-v7&lt;/code&gt; 这个包，而点击安装时是安装整个包仓库。因此出现上面的情况。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>android中Timer的使用</title>
        <link>http://blog.withouz.com/2016/06/12/android-timer.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/06/12/android-timer.html</guid>
        <pubDate>Sun, 12 Jun 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;安卓中的Timer是个定时器，它的黄金搭档是TimerTask。&lt;/p&gt;

&lt;p&gt;Timer的作用是在指定的时间执行某项任务，而TimerTask就是这个任务的载体。&lt;/p&gt;

&lt;p&gt;eg:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new Timer().schedule(new TimerTask() {
            @Override
            public void run() {
                // do something
            }
        },delay,period);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;delay参数是表示要延迟多长时间执行这个task。&lt;/p&gt;

&lt;p&gt;period参数可选，表示隔多长时间循环执行，没有这个参数表示单次执行。&lt;/p&gt;

&lt;p&gt;Timer一般一个Activity(Service)里只需要一个，在使用前注意要清理一下内存，免得多个同样的task在Timer中执行。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>AS在模拟器上调试的问题</title>
        <link>http://blog.withouz.com/2016/05/27/as-use-issue.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/05/27/as-use-issue.html</guid>
        <pubDate>Fri, 27 May 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;在使用Android Studio运行app时，编译没什么错，但是安装到模拟器上或者genymotion上时报这样的错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;None of the 1 split apks are compatible with the current device with density 480 and abis x86.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在terminal里使用adb install也不行，看这个错误应该是CPU型号不支持，因为工程里有so文件。&lt;/p&gt;

&lt;p&gt;与Eclipse不同，遇到这样的错误，Eclipse只要在libs文件夹下建个x86的文件夹，把so文件拷贝过去在run即可。&lt;/p&gt;

&lt;p&gt;Android Studio则需要改gradlew文件：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/as_nav.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;找到这个地方：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/as_content.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个ndk的对象里加上x86即可。&lt;/p&gt;

&lt;p&gt;由于对Android Studio不是很熟悉，这是个很小的问题，但是也纠结了很久。半年不搞安卓，被甩了好几条街。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>js动态加载图片</title>
        <link>http://blog.withouz.com/2016/05/25/dynamic-load-image.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/05/25/dynamic-load-image.html</guid>
        <pubDate>Wed, 25 May 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;与移动端的native图片加载不同，native的图片加载、大小处理、显示全靠自己手动完成。而html历史悠久，因此在屏幕显示图片很智能。&lt;/p&gt;

&lt;p&gt;只要告诉img标签，图片地址在哪里，即可完成图片加载、处理和显示，整个图片下载和图片大小处理全不用管。&lt;/p&gt;

&lt;p&gt;但这个智能同事也限制了移动端的表现。移动端不像PC端，有足够的空间提供图片处理，因此在移动端的img标签就显得不尽如意。&lt;/p&gt;

&lt;p&gt;特别是列表式的图片显示，看上去就很糟糕。&lt;/p&gt;

&lt;p&gt;尽管如此，万能的程序员都总是有办法的，且看我们的移动端html5的列表图片优化策略。&lt;/p&gt;

&lt;p&gt;我们先看看native的图片加载：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/native-image-show.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;native图片加载，一般都有这样几个原则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;屏幕外的图片不加载&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;屏幕滑动时不加载&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图片加载进行压缩处理&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图片加载后进行缓存&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;native显示一张图片要做这么多工作。再看我们html5的图片显示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/web-image-show.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然简单粗暴，但是跟native在移动端比性能就差远了。&lt;/p&gt;

&lt;p&gt;不过我们对比上面的方式，我们也可以借鉴一下native的加载。&lt;/p&gt;

&lt;p&gt;native在图片加载完成前一半是显示一张本地默认图片，等图片下载完成、处理好后替换默认图片。&lt;/p&gt;

&lt;p&gt;因此我们web端也可以这么干。原理大概是这样：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;第一步 我们先把img标签的src属性放置一张早就加载好的图片，把真实的图片放到一个自定义属性里，比如data-src；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第二步 找出在屏幕内的img标签，并逐一将属性data-src的值放到src属性里；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第三步 监听dom滑动，并在监听里执行第二步&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样一来，大大减小了单位时间内的图片加载负担，提升了体验。&lt;/p&gt;

&lt;p&gt;参考实例：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/dcloudio/mui&quot;&gt;https://github.com/dcloudio/mui&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/barretlee/lazyload&quot;&gt;https://github.com/barretlee/lazyload&lt;/a&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>蜕变</title>
        <link>http://blog.withouz.com/2016/05/22/tuibian.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/05/22/tuibian.html</guid>
        <pubDate>Sun, 22 May 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;来深圳后，感觉自己每时每刻都在变。有时候感觉是在往好的方向，有时候在往坏的方向。&lt;/p&gt;

&lt;p&gt;而更多的时候，自己也不确定这种变是否是好，或者是否是坏。因为很多的变化可能不是及时产生作用的，不会像烟花爆竹一样，一声响后灰飞烟灭。&lt;/p&gt;

&lt;p&gt;这种变化会慢慢积累，慢慢生效。&lt;/p&gt;

&lt;p&gt;其实，我们不用去考虑太多，因为未来的事情充满变数，我们无法左右。我们能做的，是回顾以往，总结以往，用作计划短期或者长期的一些经验，这就够了。&lt;/p&gt;

&lt;p&gt;从大学毕业到现在，自我感觉最大的一个变化应该是心态。&lt;/p&gt;

&lt;p&gt;刚参加工作那会，总是能把工作和生活分的很清楚。下班后基本不会再愿意多花一秒钟的时间在与工作有关的事情上。甚至快到下班点时会数着时间过，跟在学校时上到上午第四节课的感觉。上班会看心情，心情不好就会上网聊天，在同学群里搞气氛，心情好时才会处理手头的事情。&lt;/p&gt;

&lt;p&gt;而现在呢，总是会想着明天要做些什么事情，应该怎么安排，如果遇到问题应该怎么办，完不成怎么办，同事不配合怎么办。总是会把第二天的工作量考量一遍。而工作过程中，强迫症也渐渐滋生，越来越觉得，办好事情本来就很难，自己还觉得可有可无就会办不下来，一定要去推，一定要去做。别人做不来的事情，不要自己也做不来，而是一定要尽最大努力做下来。&lt;/p&gt;

&lt;p&gt;而很多事情，往往只要秉着一颗能做到的心，就会办下来，而办下来了，就会觉得，其实也没那么难。也因为这样的心态，因此工作状态基本也改成了在工作时间基本不会做与工作无关的事情。&lt;/p&gt;

&lt;p&gt;也因此，工作慢慢在吞噬着自己的时间，从每天8小时，到10小时，从工作日到双休日。&lt;/p&gt;

&lt;p&gt;这些不是最可怕的，可怕的是，心态上会觉得，工作本来就是生活的一部分。&lt;/p&gt;

&lt;p&gt;我们很难给这种心态定义成不好的。因为很明显，你在这份工作上的成长是很快的，能很快把职能发挥出来，这是企业希望的，因此你也更有机会往上走。&lt;/p&gt;

&lt;p&gt;但另一方面，我能很明显感觉到我的自我学习时间越来越少，自由支配时间越来越少，从工作日的早晚时间减少到双休日的剥夺。我无法花更多的时间在与工作无关的学习和成长上。&lt;/p&gt;

&lt;p&gt;但是，这不是一个人或者一个单位的责任。这是这个时代的责任，这个时代的运行模式是这样的，人类的演进方式是这样的。&lt;/p&gt;

&lt;p&gt;作为一个只有劳动资本的个体，只有拿出足够的时间成本来换取想要的生活资源。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>闲谈</title>
        <link>http://blog.withouz.com/2016/05/19/free-talk.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/05/19/free-talk.html</guid>
        <pubDate>Thu, 19 May 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;上一次写博客还是上个月，说好的每个月至少3篇博客，平均每10天一篇，结果今天已经20号，说明已经拖了两期。&lt;/p&gt;

&lt;p&gt;王小波说人的一生是牛受锤的过程，慢慢下蹲直至躺下。&lt;/p&gt;

&lt;p&gt;近半年来的最深感受就是真正属于自己的时间越来越少，越来越。&lt;/p&gt;

&lt;p&gt;之前总还能允许自己花个几个小时在键盘上挤一点文字出来，现在却几乎很少。&lt;/p&gt;

&lt;p&gt;计划里总是给自己安排了很多事，要跑步、要游泳、要看书、要写字,要打理博客…，而实际付诸行动的事情却少之又少。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>nodejs应用实现微信登录</title>
        <link>http://blog.withouz.com/2016/05/05/node-app-weixin-auth-login.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/05/05/node-app-weixin-auth-login.html</guid>
        <pubDate>Thu, 05 May 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;web应用使用微信登录的方式有多种。&lt;br /&gt;
比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;扫码登录&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;微信应用里授权登录&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最终目的无非就一个：微信授权给web应用获取用户信息，实现简易登录。&lt;/p&gt;

&lt;p&gt;技术层面，实现流程也基本一致。&lt;/p&gt;

&lt;p&gt;可以分为几步：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 第一步：用户同意授权，获取code&lt;/li&gt;
  &lt;li&gt;2 第二步：通过code换取网页授权access_token&lt;/li&gt;
  &lt;li&gt;3 第三步：刷新access_token（如果需要）&lt;/li&gt;
  &lt;li&gt;4 第四步：拉取用户信息(需scope为 snsapi_userinfo)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;步骤不难，下面我们来看nodejs的应用怎么做。&lt;/p&gt;

&lt;p&gt;这个案例是nodejs的express的应用，coffee代码。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一步 应用定向到微信登录地址&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;app.get &quot;/wx_login.html&quot;,(req,res) -&amp;gt;
  # 准备微信授权地址
  wxUrl = &quot;https://open.weixin.qq.com/connect/oauth2/authorize?&quot; 
  appid = &quot;appid=&quot; + wx_appid
  # 回调地址
  redirect_uri = &quot;redirect_uri=http%3A%2F%2F&quot; + wx_redirect_uri +&quot;%2Fwx_token.html&quot;
  response_type = &quot;response_type=code&quot;
  scope = &quot;scope=snsapi_userinfo&quot;
  wx_state = &quot;state=cfmall#wechat_redirect&quot;
  # 拼装授权地址完成
  authUrl = wxUrl + appid + &quot;&amp;amp;&quot; + redirect_uri + &quot;&amp;amp;&quot; + response_type + &quot;&amp;amp;&quot; + scope + &quot;&amp;amp;&quot; + wx_state
  # 重定向请求，转向微信授权页面，用户授权后会进入上面的毁掉地址wx_token.html并把微信的code传过来
  res.redirect authUrl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一步做的工作就是获取code。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第二步 获取token&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;app.get &quot;/wx_token.html&quot;,(req,res) -&amp;gt;
  # 获取微信回传的code
  code = req.query.code
  if !code
  	# 出错处理，做登录失败处理
    res.redirect &#39;index.html&#39;
    return;
  # 组装获取token的url
  code = &quot;code=&quot; + code
  tokenUrl = &quot;https://api.weixin.qq.com/sns/oauth2/access_token?&quot;
  appid = &quot;appid=&quot; + wx_appid
  secret = &quot;secret=&quot; + wx_secret
  grant_type= &quot;grant_type=authorization_code&quot;
  access_token_url = tokenUrl + &quot;&amp;amp;&quot; + appid + &quot;&amp;amp;&quot; + secret + &quot;&amp;amp;&quot; + code + &quot;&amp;amp;&quot; + grant_type
  # 组装完成，开始请求
  http.get access_token_url
  , (response) -&amp;gt;
    response.on &#39;data&#39;, (data) -&amp;gt;
      if data
      	# 拿到token后开始获取用户信息
        userInfoUrl = &quot;https://api.weixin.qq.com/sns/userinfo?access_token=&quot;
        openId = &quot;&amp;amp;openid=&quot;
        lang = &quot;&amp;amp;lang=zh_CN&quot;
        data = JSON.parse data.toString()
        infoUrl = userInfoUrl + data.access_token + openId + data.openid + lang
        http.get infoUrl
        , (infoRes) -&amp;gt;
          infoRes.on &#39;data&#39;, (wxData) -&amp;gt;
            # 获取用户信息 wxData
            app_obj.wxInfo = wxData
            # do something
          infoRes.on &#39;error&#39;, (e) -&amp;gt;
            # 错误处理 do something
      else
        # 错误处理 do something
    response.on &#39;error&#39;, (e) -&amp;gt;
      # 错误处理 do something
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;that’s all.&lt;/p&gt;

&lt;p&gt;是的，就是这么简单。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>express代理转发请求</title>
        <link>http://blog.withouz.com/2016/04/18/express-proxy-issue.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/04/18/express-proxy-issue.html</guid>
        <pubDate>Mon, 18 Apr 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;在浏览器中，我们使用js发送ajax请求非当前域名的服务器时，是有跨域的问题的。&lt;br /&gt;
也就是说，如果我们在js里请求第三方服务器是会被浏览器拦截，导致请求失败。&lt;br /&gt;
这个问题有两种解决方案：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;请求的第三方服务器设置response的header，对响应头不要限制请求方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过请求自己的服务器，服务器代理这个请求转发出去。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一种通常我们可能没有去操作的权限。&lt;br /&gt;
通常我们会使用第二种，因为我们对自己的服务器有充分的权限。&lt;br /&gt;
如果是express的后台，我们需要注意几个点，才能顺利的完成整个代理流程。&lt;br /&gt;
先看看代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http = require &#39;http&#39;
url = require &#39;url&#39;
_ = require &#39;underscore&#39;
queryString = require &#39;querystring&#39;

module.exports = (options) -&amp;gt;

  return (req, res, next) -&amp;gt;
    # 查找符合规则的代理配置
    k = _.chain(options).keys().find (k) -&amp;gt;
      req.url.match new RegExp(k)
    .value()
    unless k
      next()
    else
      server_config = options[k]
      #get the right url from routing
      if k != req.url
        # find in the route&#39;s definition
        if k.indexOf(&#39;*&#39;) &amp;gt; 0
          regex = new RegExp(k.replace(&#39;*&#39;, &#39;(.+)&#39;));
          path = regex.exec(req.url);
          server_config = server_config.replace(&#39;*&#39;, path.splice(1)) if path
      console.log &quot;proxy #{req.url} to remote service #{server_config}&quot;
      req_opt = url.parse server_config
      # TODO handle error event to avoid exit with error because of wrong proxy
      # console.log &quot;#{JSON.stringify(req_opt)}&quot;
      console.log req.body
      req_options = {
        hostname: req_opt.hostname
        port: req_opt.port
        path: req_opt.path
        method: req.method
        headers: {}
      }
      request = http.request req_options
      , (response) -&amp;gt;
        res.writeHead response.statusCode, response.headers
        response.pipe(res)
        response.on &#39;data&#39;, (data) -&amp;gt;
          console.log &quot;代理转发[服务器]响应: #{response.statusCode}, #{data.toString()}&quot;

        response.on &#39;error&#39;, (e) -&amp;gt;
          console.log &#39;problem with response: &#39; + e.message
      #catch exception
      request.on &#39;error&#39;, (e) -&amp;gt;
        console.log &quot;error happend when write to the background server, #{e}&quot;
      request.write(queryString.stringify(req.body))
      request.end()
      req.on &#39;error&#39;, (e) -&amp;gt;
        console.log &#39;problem with request: &#39; + e.message

      req.on &#39;end&#39;, -&amp;gt;
        request.end()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是coffee代码，主要逻辑就是：拦截请求——&amp;gt;匹配需要代理的请求——&amp;gt;组装代理请求http.request——&amp;gt;设置request的参数——&amp;gt;发送请求——&amp;gt;得到的响应结果返回.&lt;br /&gt;
需要注意两个点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;代理请求的options的headers不能使用前请求的req.headers，这样会导致直接返回404，原因没详查。因此这里就填了{}&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;代理转发的写入时需要使用到body-parser这个插件否则读取req.body是空的。这个在配置express的时候使用即可。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
      </item>
    
      <item>
        <title>使用node-inspector调试node服务端代码</title>
        <link>http://blog.withouz.com/2016/04/14/node-inspector-debug.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/04/14/node-inspector-debug.html</guid>
        <pubDate>Thu, 14 Apr 2016 00:00:00 +0800</pubDate>
        <description>&lt;ul&gt;
  &lt;li&gt;安装node-inspector&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;npm install -g node-inspector
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;启动node-inspector&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;node-inspector
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动之后会有&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Node Inspector v0.12.8&lt;br /&gt;
Visit http://127.0.0.1:8080/?port=5858 to start debugging.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;的提示，只要在浏览器访问这串地址就可以；&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;开启服务&lt;br /&gt;
比如coffee就用：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;coffee --nodejs --debug runtime-server.coffee
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动后，就可以在浏览器里看到后台的代码了。可以跟前端代码一样调试。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>基于runtime的清理工具</title>
        <link>http://blog.withouz.com/2016/04/03/clean-project-tool.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/04/03/clean-project-tool.html</guid>
        <pubDate>Sun, 03 Apr 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;上周五突发奇想，我们的project为什么不做一个自动清理的工具？&lt;/p&gt;

&lt;p&gt;因为基于runtime的工程如果大起来了，项目里肯定会产生一些垃圾文件。&lt;/p&gt;

&lt;p&gt;但是人工去处理肯定是一个很头疼的事情，因此有一个自动化垃圾文件清理的工具是必要的。&lt;/p&gt;

&lt;p&gt;于是想着应该从哪方面入手。&lt;/p&gt;

&lt;p&gt;像eclipse或者android studio这样的IDE是有一些小工具清理工程的。基于Java的Android进行自动化清理时比较好实现的。&lt;/p&gt;

&lt;p&gt;Java的所有class文件开头都会有文件依赖申明，因此只要从程序入口逐个检查文件及依赖，便可达到清理目的。&lt;/p&gt;

&lt;p&gt;我们的runtime是基于JS，特别是我们脱离了IDE的runtime来开发大型项目时，就会有很多编程规范没有严格按照runtime的规则来编写，因此会给项目清理带来一定困难。&lt;/p&gt;

&lt;p&gt;我们基于IDE的runtime去做app，那工程是易维护的，所有组件和模板以及页面都是通过json申明进行引用，因此我们按照json文件来清理整个项目是可以达到目的的。&lt;/p&gt;

&lt;p&gt;虽然我们的项目没有严格按照IDE的runtime要求的规则来开发，但是同样也可以先根据json文件来清理项目。&lt;/p&gt;

&lt;p&gt;思路是这样的，由于我们的runtime的代码渲染出界面来是依赖浏览器的，因此清理工作也可以浏览器界面化。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;在浏览器里发起一个清理请求，后台遍历json，找出脱离依赖的文件，展示到前端,前端可以一览可能是垃圾的文件，然后通过一键清理或者手动清理这些文件。&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;这个方法的可靠性是不大的，因为部分自定义组件和模板我们没有在json文件里申明依赖，而是直接在代码中去使用，因此也会当成垃圾文件扫描出来，这时我们就得依靠开发者对工程的熟练度来处理这种文件了。&lt;/p&gt;

&lt;p&gt;后续是可以强化这个工具的，比如可以检查每个文件是否在js代码里有用到。&lt;/p&gt;

&lt;p&gt;但另一方面也说明，我们应该严格按照runtime的规则，自定义组件和模板只能通过json文件去引用，这样就更易于项目的管理和维护。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>安卓面试题库</title>
        <link>http://blog.withouz.com/2016/03/24/android-interview.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/03/24/android-interview.html</guid>
        <pubDate>Thu, 24 Mar 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;在github上下载了一份面试题，花了些时间做了一遍。&lt;br /&gt;
多媒体那块的就没做了，但也记在这里。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;安卓学习途径, 寻找资料学习的博客网站&lt;/li&gt;
  &lt;li&gt;AndroidStudio使用, 插件使用, 通用的调试工具&lt;/li&gt;
  &lt;li&gt;安卓和苹果的区别&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;四大组件&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;Content Provider&lt;/li&gt;
        &lt;li&gt;Service&lt;/li&gt;
        &lt;li&gt;Activity&lt;/li&gt;
        &lt;li&gt;BroadCast Receiver&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;五大存储方式&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;Shared Preference&lt;/li&gt;
        &lt;li&gt;sqlite DB&lt;/li&gt;
        &lt;li&gt;file&lt;/li&gt;
        &lt;li&gt;远程存储&lt;/li&gt;
        &lt;li&gt;Content Provider&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Layout布局有哪几种 FrameLayout什么时候用&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;h3 id=&quot;section&quot;&gt;5种布局方式&lt;/h3&gt;
      &lt;p&gt;分别为： FrameLayout,LinearLayout,RelativeLayout,TableLayout,AbsoluteLayout&lt;br /&gt;
FrameLayout 通常在自定义组件或者自由布局时使用&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ListView的优化&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;视图重用&lt;/li&gt;
        &lt;li&gt;子组件的监听只加载一次&lt;/li&gt;
        &lt;li&gt;图片异步加载&lt;/li&gt;
        &lt;li&gt;数据与UI绑定&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点击事件设置监听的几种方式&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;自定义类继承View.OnClickListener&lt;/li&gt;
        &lt;li&gt;使用匿名类&lt;/li&gt;
        &lt;li&gt;Activity继承View.OnClickListener&lt;/li&gt;
        &lt;li&gt;在layout文件里使用onclick属性指定方法名&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安卓主线程和子线程的关系&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;主线程指支撑APP运行的线程，负责APP的UI绘制工作，在主线程里不能进行网络请求的操作，也尽量不要在   主线程里进行耗时的操作。&lt;br /&gt;
子线程与主线程的通信一般是通过handler，主线程向子线程通信可以通过接口(interface)&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Activity生命周期 onStart onResume区别&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;onStart是Activity创建后执行，重新返回时可能不会执行onStart；&lt;br /&gt;
onResume是Activity创建和重启都会走的一个方法，只要Activity出现在屏幕上，就会执行onResume&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Fragment生命周期 Activity和Fragment区别&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Fragment的生命周期和Activity类似&lt;br /&gt;
Fragment是在Android3.0之后出现的，是Activity的一个组成部分，一个Activity可以有多个Fragment，Fragment不能脱离Activity单独存在&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;页面之间如何传递数据, 如果传递一个对象如何处理, 如何传递集合&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;页面之间的数据传递可以通过Intent传值，或者使用onActivityForResult回传；&lt;br /&gt;
如果是对象可以把对象序列化转成Serializable或者Parcelable传递&lt;br /&gt;
集合可以转成List传递&lt;br /&gt;
也可以通过第三方工具进行传值&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;dp px sp的区别&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;dp 与密度无关的像素单位，在不同设备上及时像素密度不一样，但dp的大小是不便的。&lt;br /&gt;
px 1px 就是1个像素点。&lt;br /&gt;
sp 跟尺寸无关的像素单位，一般处理字体的大小。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gravity和layout_gravity的区别&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;gravity是元素本身的内容摆放规则;&lt;br /&gt;
layout_gravity是元素相对于父元素的摆放规则&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;margin和padding的区别&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;margin是外边距&lt;br /&gt;
padding是内补白&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;weight的作用&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;控制元素在父元素的所占大小的比例。只适用于线性布局&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Handler机制&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;由Handler MessageQueue Looper三步分组成&lt;br /&gt;
Handler负责 消息的收发，MessageQueue负责存储，Looper负责管理消息&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是ANR, 如何避免&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Android Not Responsing&lt;br /&gt;
安卓定义的主线程响应时长为5秒，如果5秒内没响应，则会回收APP进程&lt;br /&gt;
耗时的工作在子线程里做。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显式意图和隐式意图区别,隐式意图的使用&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;显式意图一般用于APP内，具有明确的目标页面&lt;br /&gt;
隐式意图一般用于APP之间的调用，只要申明意图的标志，比如打开浏览器的意图。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;广播几种接收方式, 广播有几种类型, 区别&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开启Service的几种方式, 区别, Service和Activity之间如何传递数据&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;h3 id=&quot;section-1&quot;&gt;两种&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li&gt;startService&lt;/li&gt;
        &lt;li&gt;bindService&lt;br /&gt;
传递数据：&lt;br /&gt;
广播、Interface、Handler、bind对象&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Service中如果要start一个Activity要如何特殊处理,为什么&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;隐式启动。&lt;/li&gt;
        &lt;li&gt;启动时标记Intent的NEW_TASK&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自定义控件&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;简单的组合自定义控件&lt;br /&gt;
图文混排的自定义控件，需要重写View的一些方法&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;常用开源框架的使用&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;OKHttp,Volley,xUtils,EventBus&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动画类型&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Tweens&lt;br /&gt;
Frame&lt;br /&gt;
Animation&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;任务栈,页面启动方式&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;standard,singleTask,singleTop,singleInstence&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Material Design / 新控件RecyclerView CardView等使用&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;RecyclerView智能化了ListView&lt;br /&gt;
CardView即卡片View，也是智能化的View，实现某类业务很简单。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图片压缩和双缓存原理&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;Matrix&lt;/li&gt;
        &lt;li&gt;双缓存：&lt;br /&gt;
先通过setBitmap方法将要绘制的所有的图形绘制到一个Bitmap上也就是先在内存空间完成，然后再来调用drawBitmap方法绘制出这个Bitmap，显示在屏幕上&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多层View的onTouch事件分发&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;GroupView-&amp;gt;ChildView-&amp;gt;GroupView&lt;br /&gt;
呈U形分发事件&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Android绘制原理 onMeasure onLayout onDraw作用&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;onMeasure View的大小计算，视图的最终大小在这里确定&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;onLayout操作用于设置视图在屏幕中显示的位置&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;onDraw会将前两部操作后的参数：大小和位置等，将内容绘制到屏幕&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是MVC MVP,区别&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;MVC 是 把软件分为三个部分：Model,View,Controller.三者相互作用&lt;br /&gt;
MVP 是把软件分为：Model, View, Presenter.Model 和View通过Presenter相互通信&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;响应式编程&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;一种面向数据流和变化传播的编程方式.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;常见开源框架源码&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;Android&lt;/li&gt;
        &lt;li&gt;Volley&lt;/li&gt;
        &lt;li&gt;LruCache&lt;/li&gt;
        &lt;li&gt;xUtils&lt;/li&gt;
        &lt;li&gt;VLC&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;单元测试常用框架和实际使用 场景&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Monkey 自动化测试&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-2&quot;&gt;多媒体&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;音频的环绕声和混响等如何处理&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;音频录制播放&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;视频的录制和播放&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;播放使用的常用框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Android原生支持格式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软解码硬解码的区别&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果要做一个按住屏幕右侧滑动调整声音功能如何处理&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    
      <item>
        <title>下雨的周末</title>
        <link>http://blog.withouz.com/2016/03/19/rain-of-runtime.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/03/19/rain-of-runtime.html</guid>
        <pubDate>Sat, 19 Mar 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;来深圳三年，基本上只要出门就会带伞，但今天，着实淋成了一只鸡。&lt;/p&gt;

&lt;p&gt;最近深圳又掉进了潮到发霉的回南天，墙上地上走廊全是水。早上跑步回来，洗完澡后就看着整阳台的衣服发呆，仿佛能听见他们一脸无辜的说：怪我咯。&lt;/p&gt;

&lt;p&gt;只好回头去柜子里掘漏网之鱼，最后翻出了去年夏天的旧衬衫解了燃眉之急。&lt;/p&gt;

&lt;p&gt;解决了遮羞之需后开始一天的行程。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;骑自行车去河边采泥。自从上次挖的蒲公英被随便种活了之后便起意挖泥来种菜。出门顺便把自行车装上后座。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;十二点参加开源中国举办的一个技术分享会。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;晚上看电影。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;出门时阳光温柔的挂在巷子的尽头，显然在说回南天很快就要过去。&lt;/p&gt;

&lt;p&gt;轮子穿出拥挤的小巷，滚到大街上时，发现满街的落叶，空中还在大片大片的掉落，阳光一直跟在后面，拉着老长的身影。仿佛瞬间到了另外一个世界。&lt;/p&gt;

&lt;p&gt;很快就到了河边，行了一段，来到一条桥下。&lt;/p&gt;

&lt;p&gt;这里上次采蒲公英的时候来过，上次恰好看到有人在这里松土栽草。所以就直奔这里，装了一袋子泥。&lt;/p&gt;

&lt;p&gt;时间很紧，很快就到了中午。会议的地点7公里左右，不远，因此决定骑车去。&lt;/p&gt;

&lt;p&gt;会场很大，三个投影屏幕场里坐着四五百号人。&lt;/p&gt;

&lt;p&gt;会分上下半场，上半场讲了两个知识点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一个是React Native相关的，腾讯的全民K歌APP开发负责人讲解整个开发过程和一些技术点，讲的很好，收益颇多。&lt;/li&gt;
  &lt;li&gt;第二个是OpenStack相关的云数据库技术，这块没怎么了解，也不怎么听的懂，听讲过程还分神。深感隔行如隔山这话的正确性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;中场休息有披萨饼伺候。&lt;/p&gt;

&lt;p&gt;下半场也是两个知识点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一个是我们公司的技术老大出讲，整个讲解过程相当到位，技术的深入浅出，全方位的介绍整个技术架构和产品，另外语速和时间把控都是全场最出色的，以及最后充分发挥讲台上的时间，给自己和公司做推广，最后的提问环节也是一问三答，精准简洁的回答了每个提问者的问题。&lt;/li&gt;
  &lt;li&gt;第二个是网易蜂巢的CaaS技术相关，第一次听到CaaS这个词，C即Container,容器即服务，核心就是最近很火的docker技术。我的浅陋理解就是一站式云打包服务，但其实里面涉及的技术相当深广，很多都只能云里来雾里去。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后是抽奖的环节，猫了一条很带感的开源内裤，真的解了回南天里的一周内衣服不干的问题。&lt;/p&gt;

&lt;p&gt;会议结束，出来发现太阳不见了，雨来了，心中开始打鼓，天黑，没带手电筒，下雨，没带伞。&lt;/p&gt;

&lt;p&gt;还没骑到一半就开始电闪雷鸣，最后倾盆大雨，回到家时踏踏实实的变成了一只落汤鸡。&lt;/p&gt;

&lt;p&gt;所幸的是，回到家有香到醉的娘酒鸡，洗完澡有开源内裤。&lt;/p&gt;

&lt;p&gt;^.^&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>js修改title在iOS的微信浏览器上不成功</title>
        <link>http://blog.withouz.com/2016/03/14/modify-title-on-iOS-Weixin.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/03/14/modify-title-on-iOS-Weixin.html</guid>
        <pubDate>Mon, 14 Mar 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;这是在iOS微信上的html5有一个bug，在Android的微信上不存在。&lt;br /&gt;
由于微信上的title是native的，因此js修改网页的title不能及时生效，只有跳转到新的页面才能刷新title，所以对于SPA来说很可怕。&lt;br /&gt;
有一个黑魔法式的解决方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.title = &quot;title&quot;;
var $body = $(&#39;body&#39;);
var $iframe = $(&#39;&amp;lt;iframe src=&quot;/favicon.ico&quot;&amp;gt;&amp;lt;/iframe&amp;gt;&#39;);
$iframe.on(&#39;load&#39;,function() {
  setTimeout(function() {
      $iframe.off(&#39;load&#39;).remove();
  }, 0);
}).appendTo($body);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原理是，因为刷新页面时能及时显示title，这个代码就是用iframe做了一次伪请求，在body中添加一个iframe标签，请求成功之后再移除dom，相当于什么也没做，但是页面标题刷新了。&lt;br /&gt;
这个解决方法相当酷。&lt;br /&gt;
方法来自于网络。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>矩阵的运算</title>
        <link>http://blog.withouz.com/2016/03/07/matrix-study.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/03/07/matrix-study.html</guid>
        <pubDate>Mon, 07 Mar 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;今天搞懂了矩阵的运算，加，减，乘。加减都很容易理解，乘法有点难理解，但是跟线性方程式放在一起，就比较容易理解。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;矩阵的加法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两个矩阵相加，是每个矩阵的每个对应的位置上的数字相加。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;矩阵的减法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两个矩阵相减，是前一个矩阵的每个位置上的数字减去第二个矩阵的对应位置上的数字的结果&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;矩阵的乘法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两个矩阵相乘，结果矩阵的第m行第n列的数值是第一个矩阵的第m行的每个值与第二个矩阵的第n列的对应位置上的每个值相乘的结果再相加后的值。&lt;/p&gt;

&lt;p&gt;这在线性方程式中很有用，比如线性方程式中有两个方程式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3x+7y=10
5x+6y=14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以用矩阵表示成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;| 3  7 |   | x |   | 10 |
| 5  6 |   | y |   | 14 |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/09/matrix-multiplication.html&quot;&gt;http://www.ruanyifeng.com/blog/2015/09/matrix-multiplication.html&lt;/a&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>三毛的撒哈拉</title>
        <link>http://blog.withouz.com/2016/03/05/read-book-sahala.html</link>
        <guid isPermaLink="true">http://blog.withouz.com/2016/03/05/read-book-sahala.html</guid>
        <pubDate>Sat, 05 Mar 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;《撒哈拉的故事》是最近在读的一本书，三毛写的，三毛原名陈懋（mào）平，后来觉得懋字难写，改名陈平。&lt;/p&gt;

&lt;p&gt;在此之前，只是道听途说仅知其笔名。&lt;/p&gt;

&lt;p&gt;也曾偶尔接触到关于三毛的文集，但稍阅一二不解其意就放弃。&lt;/p&gt;

&lt;p&gt;最近看她的撒哈拉时，觉得整个人都被她带进了沙漠，更是被笔下的三毛所蛊惑，世间纵有如此奇女，真是蛙眼大开。&lt;/p&gt;

&lt;p&gt;三毛是自由洒脱的。&lt;/p&gt;

&lt;p&gt;当她跟周身的朋友说要去撒哈拉生活时，几乎所有的朋友都反对，甚至不顾虑荷西的感受，纵然前往。当时的时代背景下能干这种事，用现在的话说就是要逆天。&lt;/p&gt;

&lt;p&gt;但她绝非薄情寡义之人。&lt;/p&gt;

&lt;p&gt;后来荷西率先去沙漠找工作给她做安居的铺垫。三毛内心就已笃定要以身相许。以及后来在沙漠与非洲土著的生活种种，更是让人咋舌。&lt;/p&gt;

&lt;p&gt;她的邻居都是非洲的土著，他们的生活以及观念都非常接近原始。因此给三毛带来不少常人无法忍受的麻烦。&lt;/p&gt;

&lt;p&gt;比如邻居经常会来她家借东西，无论什么东西都借，吃饭用的餐具，每次吃饭前邻居就会使唤小孩来借餐具，刀叉碗筷。借的次数多了，三毛就干脆给他们买了一套，但是下次吃饭点时那个小孩依旧出现在门口，说是借餐具。三毛忍不住问刚给你们买了一套怎么不用？小孩一脸无辜的说：我妈觉得那是新的，要收起来以后再用。无奈三毛还是借了。&lt;/p&gt;

&lt;p&gt;有一次三毛家里没火柴了，去找邻居借火柴，找了好几家都说没有了。后来一家给她3根火柴。三毛不好气的说：你这火柴还是我前几天借给你五盒，你你怎么忘了？邻居说：现在只剩下一盒了，要省着点用，只能给你这么多了。&lt;/p&gt;

&lt;p&gt;三毛不但不责怪这些原始部落的人，还感谢他们造就了她的性格和意念。&lt;/p&gt;

&lt;p&gt;由于邻居几乎无现代文明观念，一丁点小病就不知怎么办，因此三毛很快就成了众人眼中的巫医。让人捧腹的是有一次她用指甲油给邻居补牙，邻居还乐坏了一个劲的夸赞。&lt;/p&gt;

&lt;p&gt;感觉她整天乐呵的活在充满私欲的原始部落里，到处是原始的魔抓漫无边际，荷西曾警告她即使是年过九十的老者的话也不要相信。但黑暗的夜空偶尔也能见到闪耀的星星。&lt;/p&gt;

&lt;p&gt;一次她跟荷西去当地的一个贵族家，见到一个不说话的黑人小孩，后来得知是奴隶。&lt;/p&gt;

&lt;p&gt;黑人是当地人的俘虏，打昏捉来捆上一个月就不会再逃，后来就成了奴隶。这些奴隶被贵族派遣给西班牙人修路，西班牙人会给贵族钱，这样就形成了一条坚牢的剥削铁索。&lt;/p&gt;

&lt;p&gt;三毛见这个小奴隶实在可怜，最后偷偷的给了两百块钱。后来小奴隶的爸爸亲自来三毛家还钱，他听不见，也不会说话，但会很容易懂的手语，因此三毛称呼哑奴。哑奴表示感激不能要这个钱，而且对他们来说两百块是个天文数字。&lt;/p&gt;

&lt;p&gt;再三推让后哑奴最终收下，但后面哑奴有悄悄的给三毛送了一盆生菜（沙漠里的青菜比黄金还贵）。&lt;/p&gt;

&lt;p&gt;哑奴非常聪明，能做出非常好的水泥墙。后来三毛说他如果是自由身，他的技能足以养活一家人，他说我的身体虽然不自由，但是我的心灵是自由的。&lt;/p&gt;

&lt;p&gt;三毛给小黑奴两百块钱的时候，心里深深的厌恶自己，觉得给钱是最肤浅低级的亲善方式。&lt;/p&gt;

&lt;p&gt;我们也活在一个只剩下肤浅低级的亲善方式的世界里。亲朋好友，爹妈叔伯，孩子老婆，总是离多聚少，眼里只有钱，仿佛被这个时代奴役。&lt;/p&gt;

</description>
      </item>
    
  </channel>
</rss>